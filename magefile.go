// +build mage

package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"github.com/magefile/mage/mg"
	"github.com/magefile/mage/sh"
	"io/ioutil"
	"strings"
	"text/template"
)

const APP_NAME = "maglev-admission-webhook-golang"

// Install glide dependencies and update the lockfile for glide
func Deps() error {
	fmt.Println("Running dependency update checks...")
	if err := sh.RunV("glide","install"); err == nil {
		return sh.RunV("glide",  "update")
	} else {
		return err
	}
}

// Build Golang Binary so that it can be run on the local machine if required
func Build() error {
	mg.Deps(Deps)
	fmt.Println("Build go binary for go-webhook...")
	return sh.RunV("go","build", ".")
}

// Build Docker image for the webhook deployment
func BuildDocker() error {
	fmt.Println("Building docker images for go-webhook...")
	return sh.RunV("docker","build", ".", "-t", "harshanarayana/go-webhook:latest", "--no-cache")
}

// Generate and verify the custom SSL cert using a new signing request and approve it
func GenerateCerts() error {
	fmt.Println("Rebuilding SSL contexts...")
	return sh.RunV("ssl/generate.sh")
}

// Patch docker image with the certificate generated by the generateCerts stage
func PatchImage() error {
	//mg.Deps(GenerateCerts)
	fmt.Println("Patch harshanarayana/go-webhook:latest image to use new SSL certs")
	return sh.RunV("docker", "build", ".", "-t", "harshanarayana/go-webhook:latest", "--no-cache", "-f",  "./patch/Dockerfile")
}

// Cleanup the golang webhook from the current Kubernetes cluster
func Clean() error {
	fmt.Println("Cleaning up previous instances of %s", APP_NAME)
	_ = sh.RunV("kubectl", "delete", "ValidatingWebhookConfiguration", APP_NAME)
	_ = sh.RunV("kubectl", "delete", "MutatingWebhookConfiguration", APP_NAME)
	_ = sh.RunV("kubectl", "delete", "deployment", APP_NAME)
	_ = sh.RunV("kubectl", "delete", "svc", APP_NAME)
	return nil
}

// Deploy the golang webhook into the current Kubernetes cluster
func Deploy() error {
	mg.Deps(Clean)
	out, e := sh.Output("kubectl", "get", "configmap", "-n", "kube-system", "extension-apiserver-authentication", "-o=jsonpath='{.data.client-ca-file}'")

	if e != nil {
		return e
	}
	caBundle := base64.StdEncoding.EncodeToString([]byte(strings.TrimSpace(strings.Replace(out, "'", "", -1))))

	for _, file := range []string{"deployment.yaml", "service.yaml", "mutating.yaml"} {
		var filePath = "./deploy/" + file
		data, err := ioutil.ReadFile(filePath)
		if err != nil {
			return err
		}
		t := template.Must(template.New(file).Parse(string(data)))
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, map[string]interface{}{
			"WebHookName": APP_NAME,
			"CABundle": string(caBundle),
		}); err != nil {
			panic(err)
		}
		e = ioutil.WriteFile("/tmp/"+file, buf.Bytes(), 0755)
		if e != nil {
			return e
		}
		e = sh.RunV("kubectl", "apply", "-f", "/tmp/" + file)
		if e != nil {
			return e
		}
	}
	return nil
}
